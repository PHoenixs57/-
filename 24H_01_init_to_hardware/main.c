#include "main.h"


// volatile unsigned int delay_times;
// uart0_send_string(char* str)蓝牙调试
char Bluetooth_hello[] = "Hello world4\r\n";
int count = 0;
char Bluetooth_Buf[64];



int main(void)
{
    SYSCFG_DL_init(); 
    // Bluetooth_Init();

    uart0_send_string(Bluetooth_hello);
    uart0_send_string(Bluetooth_hello);
    delay_ms(300);
    uart0_send_string(Bluetooth_hello);
    
    // GrayScale_Init();
    // GrayScale_Start();
    Gyroscpe_Init();
    Gyroscpe_Start();
    while (1){
        // if(Gyroscpe_Data_Ready())
        // {
              
        //     // //数据解析，不接收数据，但此处只为调试，无解析
        //     // strcat(Bluetooth_Buf, wt61_ACCEL_buffer);
        //     // strcat(Bluetooth_Buf, wt61_GYRO_buffer);
        //     // strcat(Bluetooth_Buf, wt61_ANGLE_buffer);
        //     uart0_send_string(wt61_data_buffer);
        //     Gyroscpe_Start();
        // }
        // delay_ms(300);
        // uart0_send_string(Bluetooth_hello);
    }
}


// void delay_ms(unsigned int ms)
// {
//     delay_times = ms;
//     while( delay_times != 0 );
// }

void delay_ms(unsigned int ms)
{
    unsigned int i, j;
    // 下面的嵌套循环的次数是根据主控频率和编译器生成的指令周期大致计算出来的，
    // 需要通过实际测试调整来达到所需的延时。
    // The number of nested loops below is roughly calculated based on the master control frequency and the instruction cycle generated by the compiler,and needs to be adjusted through actual testing to achieve the required delay.
    for (i = 0; i < ms; i++)
    {
        for (j = 0; j < 8000; j++)
        {
            // 仅执行一个足够简单以致于可以预测其执行时间的操作
            // Perform only one operation that is simple enough to predict its execution time
            __asm__("nop"); // "nop" 代表“无操作”，在大多数架构中，这会消耗一个或几个时钟周期 "nop" stands for "no operation", which on most architectures consumes one or a few clock cycles
        }
    }
}